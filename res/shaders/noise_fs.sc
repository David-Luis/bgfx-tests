$input v_color0, v_texcoord0

#include "common/common.sh"

// Modification of https://www.shadertoy.com/view/4ssXRX
// Added a second way to do triangle noise without doing
// a second random sample.

CONST(int NUM_BUCKETS = 32);
CONST(int ITER_PER_BUCKET = 244);
CONST(float HIST_SCALE = 8.0);

CONST(float NUM_BUCKETS_F = 32.0);
CONST(float ITER_PER_BUCKET_F = 244.0);

uniform vec4 u_data;

//note: uniformly distributed, normalized rand, [0;1[
float nrand( vec2 n )
{
	return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}
//note: remaps v to [0;1] in interval [a;b]
float remap( float a, float b, float v )
{
	return clamp( (v-a) / (b-a), 0.0, 1.0 );
}
//note: quantizes in l levels
float truncate( float a, float l )
{
	return floor(a*l)/l;
}

float n1rand( vec2 n )
{
	float t = fract( u_data[0] );
	float nrnd0 = nrand( n + 0.07*t );
	return nrnd0;
}
float n2rand( vec2 n )
{
	float t = fract( u_data[0] );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );
	return (nrnd0+nrnd1) / 2.0;
}

float n2rand_faster( vec2 n )
{
	float t = fract( u_data[0] );
	float nrnd0 = nrand( n + 0.07*t );

    // Convert uniform distribution into triangle-shaped distribution.
    float orig = nrnd0*2.0-1.0;
    nrnd0 = orig*inversesqrt(abs(orig));
    nrnd0 = max(-1.0,nrnd0); // Nerf the NaN generated by 0*rsqrt(0). Thanks @FioraAeterna!
    nrnd0 = nrnd0-sign(orig)+0.5;
    
    // Result is range [-0.5,1.5] which is
    // useful for actual dithering.
    // convert to [0,1] for histogram.
    return (nrnd0+0.5) * 0.5;
}
float n3rand( vec2 n )
{
	float t = fract( u_data[0] );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );
	float nrnd2 = nrand( n + 0.13*t );
	return (nrnd0+nrnd1+nrnd2) / 3.0;
}
float n4rand( vec2 n )
{
	float t = fract( u_data[0] );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );	
	float nrnd2 = nrand( n + 0.13*t );
	float nrnd3 = nrand( n + 0.17*t );
	return (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;
}
float n4rand_inv( vec2 n )
{
	float t = fract( u_data[0] );
	float nrnd0 = nrand( n + 0.07*t );
	float nrnd1 = nrand( n + 0.11*t );	
	float nrnd2 = nrand( n + 0.13*t );
	float nrnd3 = nrand( n + 0.17*t );
    float nrnd4 = nrand( n + 0.19*t );
	float v1 = (nrnd0+nrnd1+nrnd2+nrnd3) / 4.0;
    float v2 = 0.5 * remap( 0.0, 0.5, v1 ) + 0.5;
    float v3 = 0.5 * remap( 0.5, 1.0, v1 );
    return (nrnd4<0.5) ? v2 : v3;
}

float histogram( int iter, vec2 uv, vec2 interval, float height, float scale )
{
	float t = remap( interval.x, interval.y, uv.x );
	vec2 bucket = vec2( truncate(t,NUM_BUCKETS_F), truncate(t,NUM_BUCKETS_F)+1.0/NUM_BUCKETS_F);
	float bucketval = 0.0;
	for ( int i=0;i<ITER_PER_BUCKET;++i)
	{
		float seed = float(i)/ITER_PER_BUCKET_F;
		
		float r;
		if ( iter < 2 )
			r = n1rand( vec2(uv.x,0.5) + seed );
		else if ( iter<3 )
			r = n2rand( vec2(uv.x,0.5) + seed );
		else if ( iter<4 )
			r = n2rand_faster( vec2(uv.x,0.5) + seed );
		else if ( iter<5 )
			r = n3rand( vec2(uv.x,0.5) + seed );
		else
			r = n4rand( vec2(uv.x,0.5) + seed );
		
		bucketval += step(bucket.x,r) * step(r,bucket.y);
	}
	bucketval /= ITER_PER_BUCKET_F;
	bucketval *= scale;
    
    float v0 = step( uv.y / height, bucketval );
    float v1 = step( (uv.y-1.0/u_data[2]) / height, bucketval );
    float v2 = step( (uv.y+1.0/u_data[2]) / height, bucketval );
	return 0.5 * v0 + v1-v2;
}

void main()
{
	vec2 uv = v_texcoord0;
	
	float o;
    int idx;
    vec2 uvrange;
	if ( uv.x < 1.0/5.0 )
	{
		o = n1rand( uv );
        idx = 1;
        uvrange = vec2( 0.0/5.0, 1.0/5.0 );
	}
	else if ( uv.x < 2.0 / 5.0 )
	{
		o = n2rand( uv );
        idx = 2;
        uvrange = vec2( 1.0/5.0, 2.0/5.0 );
	}
	else if ( uv.x < 3.0 / 5.0 )
	{
		o = n2rand_faster( uv );
        idx = 3;
        uvrange = vec2( 2.0/5.0, 3.0/5.0 );
	}
	else if ( uv.x < 4.0 / 5.0 )
	{
		o = n3rand( uv );
        idx = 4;
        uvrange = vec2( 3.0/5.0, 4.0/5.0 );
	}
	else
	{
		o = n4rand( uv );
        idx = 5;
        uvrange = vec2( 4.0/5.0, 5.0/5.0 );
	}

    //display histogram
    if ( uv.y < 1.0 / 4.0 )
		o = 0.125 + histogram( idx, uv, uvrange, 1.0/4.0, HIST_SCALE );
    
	//display lines
	if ( abs(uv.x - 1.0/5.0) < 0.002 ) o = 0.0;
	if ( abs(uv.x - 2.0/5.0) < 0.002 ) o = 0.0;
	if ( abs(uv.x - 3.0/5.0) < 0.002 ) o = 0.0;
	if ( abs(uv.x - 4.0/5.0) < 0.002 ) o = 0.0;
	if ( abs(uv.y - 1.0/4.0) < 0.002 ) o = 0.0;

	
	gl_FragColor = vec4( vec3(o, o, o), 1.0 );
}
